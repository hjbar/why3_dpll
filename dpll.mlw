
(* Standard library imports *)

use int.Int
use int.Abs
use array.Array

(* Helper function for clause swapping *)

use array.ArrayPermut

let swap (a:array 'a) (i:int) (j:int) : unit
  requires { 0 <= i < length a /\ 0 <= j < length a }
  writes   { a }
  ensures  { exchange (old a) a i j }
= let v = a[i] in
  a[i] <- a[j];
  a[j] <- v

(* Simple DPLL *)

type lit = int (* 1-nv .. nv-1 *)
type cls = (lit, lit, lit)

predicate is_lit (nv: int) (l: lit) =
  -nv < l < nv

predicate is_cls (nv: int) (c: cls) =
  let l1, l2, l3 = c in
  is_lit nv l1 /\ is_lit nv l2 /\ is_lit nv l3

(* An assignment stores for every Boolean variable `i`
   its "truth value", encoded as an integer, which is
   either equal to `i` or to `-i`. In this encoding,
   a non-negative truth value means that the variable
   is false, and a negative truth value means that the
   variable is true. Consequently, the variable `0` is
   always false. *)

type assignment = array int

predicate is_assignment (mm: assignment) (na: int) =
  0 < na <= length mm /\ mm[0] = 0 /\
  forall i. 0 <= i < na -> abs mm[i] = i

(* A literal `l` is true in assignment `mm` if and only if
   it has been assigned a truth value (`|l| < na`), and
   `mm[abs l]` is different from `l`. If `l` is positive,
   it is true only if `mm[l]` is negative, and if `l` is
   negative, it is true only if `mm[l]` is positive.
   If `l` is zero, `mm[l]` has to be zero, too, and
   therefore `l` can only be false. *)

predicate ok_lit (mm: assignment) (na: int) (l: lit) =
  is_lit (length mm) l /\ 0 <= abs l < na <= length mm /\
  mm[abs l] <> l

predicate ok_cls (mm: assignment) (na: int) (c: cls) =
  let l1, l2, l3 = c in
  ok_lit mm na l1 \/ ok_lit mm na l2 \/ ok_lit mm na l3

(* For every `i` such that `0` <= `i` < `len`, a1 and a2 have
   the same element at index `i`. This is a useful predicate for
   proving the completeness of the SAT algorithm. *)
predicate array_eq (a1: array 'a) (a2: array 'a) (len: int) =
  forall i. 0 <= i < len -> a1[i] = a2[i]

(* Helper lemma to assist Why3 in proving the post-condition
   for the completeness of the SAT algorithm within the
   `dpll` function.
   If `cl1` contains a clause that is not satisfied, and if
   `cl2` is a permutation of `cl1`, then `cl2` also contains
   a clause that is not satisfied. *)
lemma permut_preserve_existence_of_notOkCls :
  forall cl1 cl2: array cls, mm: assignment, n: int.
    permut_all cl1 cl2 ->
    (exists i. 0 <= i < length cl1 /\ not ok_cls mm n cl1[i]) ->
    (exists i. 0 <= i < length cl2 /\ not ok_cls mm n cl2[i])

(* Function `scan` moves the clases which are true in
   assignment `mm` outside of the active zone `cl[0..nc)`,
   and returns the new number of active clases `mc` which
   has to be smaller or equal than `nc`. It also returns
   a boolean flag `b` which is set to `false`, when a false
   clause is discovered (i.e., all three literals have been
   assigned a false truth value), and therefore the current
   assignment `mm` cannot possibly be extended to a model. *)

let scan (mm: assignment) (cl: array cls) (nv na nc: int) : (b: bool, mc: int)
  requires { nv = length mm }
  requires { 0 < na <= nv }
  requires { 0 <= nc <= length cl }
  requires { forall i. nc <= i < length cl -> ok_cls mm na cl[i] }

  writes { cl }

  ensures { 0 <= mc <= nc }
  ensures { forall i. nc <= i < length cl -> cl[i] = old cl[i] }
  ensures { forall i. mc <= i < length cl -> ok_cls mm na cl[i] }

  ensures { b -> forall i. 0 <= i < mc -> not ok_cls mm na cl[i] }
  ensures { not b -> forall mm'. is_assignment mm' nv ->
    array_eq mm mm' na -> exists i. 0 <= i < nc /\ not ok_cls mm' nv cl[i] }

  ensures { permut_all (old cl) cl }
=
  let ref i = 0 in
  let ref mc = nc in

  while i < mc do
    variant { mc - i }

    invariant { 0 <= i <= mc <= nc }
    invariant { forall j. nc <= j < length cl -> cl[j] = old cl[j] }
    invariant { forall j. mc <= j < length cl -> ok_cls mm na cl[j] }

    invariant { forall j. 0 <= j < i -> not ok_cls mm na cl[j] }

    invariant { permut_all (old cl) cl }

    let (l1, l2, l3) = cl[i] in

    if (abs l1 < na && mm[abs l1] <> l1) ||
       (abs l2 < na && mm[abs l2] <> l2) ||
       (abs l3 < na && mm[abs l3] <> l3)
    then begin
      mc <- mc - 1;
      swap cl i mc
    end
    else if (abs l1 < na && mm[abs l1] = l1) &&
            (abs l2 < na && mm[abs l2] = l2) &&
            (abs l3 < na && mm[abs l3] = l3)
    then
      return (false, mc)
    else
      i <- i + 1
  done;

  (true, mc)

(* Function `dpll` checks the current state of the search using `scan`,
   and after that, if the search can be continued, extends the current
   assignment `mm`, by giving the first unassigned Boolean variable `na`
   one or the other truth value, as per DPLL procedure. This function
   returns `true` if `mm` has been extended to a model, and `false`
   if `mm` cannot possibly be extended to a model. *)

let rec dpll (mm: assignment) (cl: array cls) (nv na nc: int) : (s: bool)
  requires { nv = length mm }
  requires { 0 < na <= nv }
  requires { 0 <= nc <= length cl }

  requires { mm[0] = 0 }
  requires { is_assignment mm na }

  requires { forall i. nc <= i < length cl -> ok_cls mm na cl[i] }

  writes { cl }
  writes { mm }

  variant { nv - na }

  ensures  { s -> is_assignment mm nv }

  ensures { forall i. nc <= i < length cl -> cl[i] = old cl[i] }
  ensures { forall i. 0 <= i < na -> mm[i] = old mm[i] }
  ensures { s -> forall i. 0 <= i < length cl -> ok_cls mm nv cl[i] }

  ensures { not s -> forall mc. is_assignment mc nv ->
    array_eq (old mm) mc na -> exists i. 0 <= i < length cl /\ not ok_cls mc nv cl[i] }

  ensures { permut_all (old cl) cl }
=
  let (b, mc) = scan mm cl nv na nc in

  if mc = 0 then begin
    for i = na to nv - 1 do
      invariant { forall j. 0 <= j < na -> mm[j] = old mm[j] }
      invariant { is_assignment mm i }

      mm[i] <- i
    done;

    true
  end
  else if (not b) || (na = nv) then false
  else begin
    mm[na] <- na;

    if dpll mm cl nv (na + 1) mc then true
    else begin
      mm[na] <- -na;
      dpll mm cl nv (na + 1) mc
    end
  end

(* Function `sat` implements a simple 3SAT solver. If it returns `true`,
   assignment `mm` contains a model of the clause set `cl`. If it returns
   `false`, the clause set `cl` is unsatisfiable. The clauses in `cl` can
   be reordered during the search. *)

let sat (mm: assignment) (cl: array cls) : (sat: bool)
  requires { 0 < length mm }
  requires { forall i. 0 <= i < length cl -> is_cls (length mm) cl[i] }
  ensures  { sat -> is_assignment mm (length mm) }
  ensures  { sat -> forall i. 0 <= i < length cl -> ok_cls mm (length mm) cl[i] }
  ensures  { not sat -> forall mc. is_assignment mc (length mm) ->
    exists i. 0 <= i < length cl /\ not ok_cls mc (length mm) cl[i] }
  ensures  { permut_all (old cl) cl }
=
  mm[0] <- 0;
  dpll mm cl (length mm) 1 (length cl)
